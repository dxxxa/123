# [How to Handle Files in Python using OS Module](https://www.thepythoncode.com/article/file-handling-in-python-using-os-module)
##
# [[] / []]()
В индустрии программного обеспечения большинство программ обрабатывают файлы тем или иным образом, например, создают файлы, переименовывают их, перемещают, перечисляют и т. Д. Как программист, вы обязательно должны обладать этим фундаментальным навыком. В результате в этом уроке мы будем использовать модуль ОС на Python для выполнения нескольких операций с файлами и каталогами независимо от операционной системы, которую мы используем.

Теперь вам нужно знать, что модуль ОС предназначен не только для обработки файлов и каталогов, он имеет массу методов и инструментов для других операций, таких как обработка переменных среды, аргументов командной строки, управления системными процессами и даже расширенных атрибутов Linux, которые специфичны для операционной системы Linux.

Хорошо, давайте начнем, так как модуль ОС является встроенным модулем, нам не нужно ничего устанавливать.

Это также может вас заинтересовать: Как получить размер каталогов в Python.

В этом уроке вы узнаете:

Печать текущего рабочего каталога
Создание каталогов
Изменение каталогов
Создание вложенных каталогов
Создание файлов
Переименование файлов
Перемещение файлов
Список файлов и каталогов
Удаление файлов
Удаление каталогов
Получение информации о файлах
Печать текущего рабочего каталога
Для того чтобы получить текущий рабочий каталог, необходимо использовать os.getcwd():

import os

# print the current directory
print("The current directory:", os.getcwd())
os.getcwd() возвращает строку Юникода, представляющую текущий рабочий каталог, вот мои выходные данные:

The current directory: C:\pythoncode-tutorials\python-standard-library
Создание каталогов
Чтобы создать папку/каталог в любой операционной системе, все, что вам нужно сделать, это:

# make an empty directory (folder)
os.mkdir("folder")
Как только вы выполните это, он сразу же породит каталог с именем «папка» в текущем рабочем каталоге.

Если вы запустите это снова, он вызовет FileExistsError, потому что папка уже существует, хороший способ решить эту проблему- запустить os.mkdir() только если папка не существует, мы можем легко сделать это:

# running mkdir again with the same name raises FileExistsError, run this instead:
if not os.path.isdir("folder"):
     os.mkdir("folder")
Функция os.path.isdir() возвращает значение True, если переданный нами путь относится к существующему каталогу.

Изменение каталогов
Довольно легко изменить каталоги, давайте перейдем к папке, которую мы только что создали:

# changing the current directory to 'folder'
os.chdir("folder")
Теперь давайте снова напечатаем рабочий каталог:

# printing the current directory now
print("The current directory changing the directory to folder:", os.getcwd())
Выпуск:

The current directory changing the directory to folder: C:\pythoncode-tutorials\python-standard-library\folder
Создание вложенных каталогов
Предположим, вы хотите создать не только одну папку, но и много вложенных папок:

# go back a directory
os.chdir("..")

# make several nested directories
os.makedirs("nested1/nested2/nested3")
Это создаст 3 папки рекурсивно, как показано на следующем рисунке:

Созданные вложенные папки

Создание файлов
Чтобы создавать файлы на Python, вам не нужен какой-либо модуль, вы можете использовать встроенную функцию open(), которая принимает имя файла, который вы хотите создать, в качестве первого параметра и режим, в котором вы хотите открыть файл, в качестве второго параметра:

# create a new text file
text_file = open("text.txt", "w")
# write to this file some text
text_file.write("This is a text file")
Я использовал «w» в качестве режима открытия файлов, который означает запись, вы также можете использовать «a» для добавления к существующим файлам или «r» для чтения существующих файлов. Дополнительные сведения о режимах открытия файлов см. на этой странице.

Переименование файлов
Переименовать файл с помощью модуля OS довольно просто, давайте переименуем файл, который мы только что создали:

# rename text.txt to renamed-text.txt
os.rename("text.txt", "renamed-text.txt")
Функция os.rename() принимает 2 параметра: имя файла или каталога, который требуется переименовать, и имя назначения, в которое требуется переименовать.

Перемещение файлов
Мы можем использовать функцию os.replace() для перемещения файлов или каталогов:

# replace (move) this file to another directory
os.replace("renamed-text.txt", "folder/renamed-text.txt")
Обратите внимание, что это перезапишет место назначения, поэтому, если в «папке» есть другой уже существующий файл, который получил то же имя «renamed-text.txt», но другое содержимое, он перезапишет его.

Связанные с: Как шифровать и расшифровывать файлы в Python.

Список файлов и каталогов
# print all files and folders in the current directory
print("All folders & files:", os.listdir())
Функция os.listdir() возвращает список, содержащий имена файлов в каталоге, мы ничего не передали в качестве параметра, поэтому она вернет файлы и каталоги текущего рабочего каталога, вот мой вывод:

All folders & files: ['folder', 'handling-files', 'nested1', 'text.txt']
Хорошо, но что, если мы хотим знать содержимое этих папок? Вместо этого нам нужно будет использовать функцию os.walk():

# print all files & folders recursively
for dirpath, dirnames, filenames in os.walk("."):
    # iterate over directories
    for dirname in dirnames:
        print("Directory:", os.path.join(dirpath, dirname))
    # iterate over files
    for filename in filenames:
        print("File:", os.path.join(dirpath, filename))
os.walk() - это генератор дерева каталогов, он будет перебирать все деревья каталогов, я передал "." как верхнюю часть этого дерева, которая ссылается на текущий рабочий каталог, вот вывод:

Directory: .\folder
Directory: .\handling-files
Directory: .\nested1
File: .\text.txt
File: .\handling-files\listing_files.py
File: .\handling-files\README.md
Directory: .\nested1\nested2
Directory: .\nested1\nested2\nested3
Я также использовал метод os.path.join() для присоединения к текущему пути, по которому мы находимся, с именем файла/каталога.

Удаление файлов
Давайте удалим тот файл, который мы создали:

# delete that file
os.remove("folder/renamed-text.txt")
os.remove() делает то, что предполагает его имя, он удаляет файл (не каталог), учитывая его путь. Кроме того, вы можете использовать os.unlink(), чтобы сделать то же самое.

Удаление каталогов
Использование функции os.rmdir() удалит заданную папку:

# remove the folder
os.rmdir("folder")
Чтобы удалить каталоги рекурсивно, нам нужно использовать функцию os.removedirs():

# remove nested folders
os.removedirs("nested1/nested2/nested3")
Это удалит все эти каталоги только в том случае, если они, конечно, пусты.

Чтобы удалить непустые каталоги (каталоги, в которых есть файлы, а также подкаталоги), нам нужно использовать метод rmtree() из shutil:

# remote non-empty folders
shutil.rmtree("nested1")
Этот метод рекурсивно удалит все дерево каталогов nested1, конечно, вам понадобятся необходимые привилегии для этого, так как это довольно опасно, если вы не знаете, что делаете.

Связанные с: Как организовать файлы по расширению в Python

Получение информации о файлах
Для того, чтобы получить некоторую информацию о данном файле в вашей операционной системе, есть классная функция os.stat(), которая выполняет системный вызов stat по заданному пути:

open("text.txt", "w").write("This is a text file")

# print some stats about the file
print(os.stat("text.txt"))
Вот выходные данные:

os.stat_result(st_mode=33206, st_ino=14355223812608232, st_dev=1558443184, st_nlink=1, st_uid=0, st_gid=0, st_size=19, st_atime=1575967618, st_mtime=1575967618, st_ctime=1575966941)
Это вернуло именованный кортеж, который получил некоторые метрики на нем, мы не будем рассматривать все эти атрибуты, но некоторые интересны:

st_size: Размер файла в байтах.

st_atime: Время последнего доступа, выраженное в секундах (метка времени).

st_mtime: Время последней модификации.

st_ctime: В Windows это время создания файла, в Unix это время последнего изменения метаданных.

Чтобы получить определенный атрибут, вы можете сделать следующее:

# get the file size for example
print("File size:", os.stat("text.txt").st_size)
Выпуск:

File size: 19
Посетите эту страницу для получения дополнительной информации об этих атрибутах.

Заключение
Как видите, очень легко обрабатывать файлы и каталоги на Python с помощью этого платформонезависимого модуля, в котором вам не нужно беспокоиться о какой-либо обработке для конкретной платформы и т. Д. Вы также можете использовать некоторые функции, специфичные для платформы, такие как os.chown() или os.chmod() для Linux.