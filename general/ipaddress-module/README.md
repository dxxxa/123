# [How to Manipulate IP Addresses in Python using ipaddress module](https://www.thepythoncode.com/article/manipulate-ip-addresses-using-ipaddress-module-in-python)
##
# [[] / []]()
В этом учебнике вы узнаете, как вы можете использовать ipaddress module для работы с IP-адресами в Python, сетевые инженеры и люди, которые разрабатывают сетевое программное обеспечение, используют этот модуль так часто, поскольку он предоставляет удобные функции и классы, которые обрабатывают различные задачи, связанные с IP-адресами, включая проверку того, принадлежат ли два хоста к одной подсети, итерация по всем узлам подсети, получение широковещательных адресов определенной подсети и многое другое.

Связанные с: Как сделать сканер сети с помощью Scapy в Python.

Нам не нужно ничего устанавливать, так как этот модуль поставляется встроенным, и он был представлен в Python 3.3, поэтому, если у вас есть Python 3.3 + (и я уверен, что вы это делаете), вы можете идти!

Начнем с класса IPv4Address:

import ipaddress
# initialize an IPv4 Address
ip = ipaddress.IPv4Address("192.168.1.1")
Теперь этот ip-объект представляет один IP-адрес, мы можем проверить, является ли он глобальным IP-адресом (не частным) и является ли он локальным по ссылке:

# print True if the IP address is global
print("Is global:", ip.is_global)

# print Ture if the IP address is Link-local
print("Is link-local:", ip.is_link_local)
Выпуск:

Is global: False
Is link-local: False
Вы также можете использовать ip.is_reserved и ip.is_multicast, чтобы проверить, находится ли этот IP-адрес в списке зарезервированных IP-адресов и адресов многоадресной рассылки соответственно.

Вы можете выполнять сложение и вычитание по IP-адресам:

# next ip address
print(ip + 1)

# previous ip address
print(ip - 1)
Вы догадались, добавление IP-адреса на 1 означает, что это следующий IP-адрес, вычитание на 1 означает предыдущий IP-адрес, вот вывод:

192.168.1.2
192.168.1.0
Поскольку я не могу охватить все доступные методы, напишите dir(ip), чтобы обнаружить различные методы и атрибуты, которые вы можете использовать.

Теперь, когда у вас есть базовое понимание объекта IPv4Address, давайте углубимся в обработку объектов IPv4Network:

# initialize an IPv4 Network
network = ipaddress.IPv4Network("192.168.1.0/24")
Теперь этот сетевой объект представляет сеть IPv4, /24 — это нотация CIDR, она указывает, что начальные 24 бита из общих 32 бит IP-адреса используются для идентификации сетевой части адреса, что означает, что в данном случае «192.168.1.x» является частью сети (3x8 = 24 бита), и только последний октет «x.x.x.0» является частью хоста.

Вы можете получить маску сети этой сети:

# get the network mask
print("Network mask:", network.netmask)
Выпуск:

Network mask: 255.255.255.0
Маска сети - это просто еще один формат (возможно, более старый) для выражения и представления сетевой части адреса, в этом случае 255.255.255.0 означает, что начальные 24 бита, которые заполнены 1 (255 11111111 в двоичном формате), указывают на сетевую часть адреса (то же самое, что и обозначение /24).

Вот как можно получить широковещательный адрес сети:

# get the broadcast address
print("Broadcast address:", network.broadcast_address)
Выпуск:

Broadcast address: 192.168.1.255
Печать количества хостов, принадлежащих этой сети:

# print the number of IP addresses under this network
print("Number of hosts under", str(network), ":", network.num_addresses)
Выпуск:

Number of hosts under 192.168.1.0/24 : 256
В этой сети доступно в общей сложности 256 хостов (включая адреса подсети и широковещательной рассылки), вот как вы можете выполнить итерацию по всем из них:

# iterate over all the hosts under this network
print("Hosts under", str(network), ":")
for host in network.hosts():
    print(host)
При этом будут напечатаны все допустимые IP-адреса узлов в диапазоне от 192.168.1.1 до 192.168.1.254.

Вы также можете получить подсети этой сети:

# iterate over the subnets of this network
print("Subnets:")
for subnet in network.subnets(prefixlen_diff=2):
    print(subnet)
Выпуск:

Subnets:
192.168.1.0/26
192.168.1.64/26
192.168.1.128/26
192.168.1.192/26
Метод network.subnets() возвращает подсети, которые соединяются, чтобы сделать текущую подсеть списком объектов IPv4Network, prefixlen_diff параметр представляет собой целое число, указывающее величину, на которую длина префикса должна быть увеличена, я установил это значение 2, чтобы я мог получить /26 подсетей.

Вы также можете получить суперсеть:

# get the supernet of this network
print("Supernet:", network.supernet(prefixlen_diff=1))
Это вернет суперсеть, содержащую текущую сеть, вот выходные данные:

Supernet: 192.168.0.0/23
Наконец, вы можете проверить, перекрывает ли сеть другую сеть:

# tell if this network is under (or overlaps) 192.168.0.0/16
print("Overlaps 192.168.0.0/16:", network.overlaps(ipaddress.IPv4Network("192.168.0.0/16")))
Выпуск:

Overlaps 192.168.0.0/16: True
Он вернул значение True, так как подсеть 192.168.1.1/24 находится в сети 192.168.0.0/16.

Хорошо, мы закончили с этим учебником, вы можете изучить этот модуль, проверив их официальную документацию для дополнительных функций и классов для IPv4, а также адресов IPv6, которые действительно удобны для сетевых инженеров и программистов Python, которые хотят разрабатывать сетевые приложения.