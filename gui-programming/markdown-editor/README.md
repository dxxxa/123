# [How to Make a Markdown Editor using Tkinter in Python](https://www.thepythoncode.com/article/markdown-editor-with-tkinter-in-python)
##
# [[] / []]()
Идея
В этом уроке мы сделаем редактор разметки, используя библиотеку GUI Tkinter и регулярные выражения. Мы сделаем так, чтобы слева была текстовая область, где пользователь пишет, и область отображения справа, где уценка слегка стилизована. Для этого нам нужно узнать о регулярных выражениях и виджете Tkinter Text и о том, как стилизовать части этих текстовых виджетов.

Давайте начнем!

Импорт
Как всегда, мы импортируем некоторые модули и библиотеки, чтобы помочь нам. Во-первых, мы получаем все от Tkinter с помощью *. С Tkinter мы создадим наш графический интерфейс пользователя (GUI). Используя этот синтаксис со звездочкой (*), мы гарантируем, что можем использовать константы, определенные Tkinter.

Поскольку окна, генерируемые Tkinter, часто выглядят не очень хорошо, мы также получаем ctypes, чтобы мы могли включить высокие точки на дюйм (DPI). Вы видите это в действии в последней строке блока кода ниже.

Наконец, мы получаем ре, который мы будем использовать для поиска шаблонов в нашем тексте. Поэтому мы также узнаем немного о регулярных выражениях:

# Imports
from tkinter import *
import ctypes
import re

# Increas Dots Per inch so it looks sharper
ctypes.windll.shcore.SetProcessDpiAwareness(True)
Настройка
Теперь перейдем к настройке Tkinter. Мы начинаем с создания нового объекта Tk и сохранения его в переменной. Затем мы устанавливаем заголовок, который появится в левом верхнем углу нашего окна. Затем мы также устанавливаем размеры окна с помощью функции geometry(). Наконец, мы установили шрифт глобально, чтобы быть курьером в размере 15:

# Setup
root = Tk()
root.title('Markdown Editor')
root.geometry('1000x600')

# Setting the Font globaly
root.option_add('*Font', 'Courier 15')
Стили
Теперь мы делаем много переменных, представляющих настройки стиля для нашей маленькой программы. Мы используем функцию для преобразования этих значений RGB в шестнадцатеричные, которые мы создаем сами. Позже мы увидим, как это сделано. Ширина используется в текстовом виджете позже:

# Style Setup
editorBackground = rgbToHex((40, 40, 40))
editorTextColor = rgbToHex((230, 230, 230))
displayBackground = rgbToHex((60, 60, 60))
displayTextColor = rgbToHex((200, 200, 200))

caretColor = rgbToHex((255, 255, 255))

# Width of the Textareas in characters
width = 10
Мы также определяем некоторые шрифты. Для области редактирования мы устанавливаем Courier, который является избыточным, но мы делаем это в любом случае. Затем мы определяем шрифт области отображения как Calibri; это может не сработать для вас, поэтому вы меняете его на Arial или любой другой шрифт, установленный на вашем компьютере. Мы также устанавливаем размеры и цвета для заголовков от слоев 1 до 3:

# Fonts
editorfontName = 'Courier'
displayFontName = 'Calibri'

# Font Sizes
normalSize = 15
h1Size = 40
h2Size = 30
h3Size = 20

# font Colors
h1Color = rgbToHex((240, 240, 240))
h2Color = rgbToHex((200, 200, 200))
h3Color = rgbToHex((160, 160, 160))
Регулярные выражения
Теперь мы также определяем список замен и стилей, сделанных в области отображения. Это список, состоящий из других списков. В этих списках первым элементом является шаблон, по которому выполняется поиск. Второе – это имя. Третье – это данные шрифта, которые в нашем случае представляют собой форматированную строку.

Четвертый — цвет, а последний — смещение. Позже мы увидим, что это значит, когда мы используем этот вложенный список. На данный момент мы увеличиваем заголовки только с одним, двумя и тремя хэштегами, и мы делаем текст, окруженный * жирным шрифтом:

# Replacements tell us were to insert tags with the font and colors given
replacements = [
    [
        '^#[a-zA-Z\s\d\?\!\.]+$',
        'Header 1',
        f'{displayFontName} {h1Size}', 
        h1Color,
        0
    ], [
        '^##[a-zA-Z\s\d\?\!\.]+$',
        'Header 2', 
        f'{displayFontName} {h2Size}',
        h2Color,
        0
    ], [
        '^###[a-zA-Z\s\d\?\!\.]+$', 
        'Header 3', 
        f'{displayFontName} {h3Size}', 
        h3Color,
        0        
    ], [
        '\*.+?\*', 
        'Bold', 
        f'{displayFontName} {normalSize} bold', 
        displayTextColor,
        2
    ],
]
Давайте посмотрим на одно из выражений: ^#[a-zA-Z\s\d\?\!\.] +$ будет соответствовать самому большому заголовку, сделанному с одним хэштегом #. ^ означает начало строки, а # означает само по себе, [a-zA-Z\s\d\?\!\.] указывает на любой символ, цифру, пробелы, '?', . или !. Мы модифицируем эту группу с помощью +, чтобы это означало один или несколько символов. И, в конце концов, у нас есть знак доллара, который означает конец строки. Мы делаем это таким образом, потому что разметка не может охватывать несколько строк, разделенных \n.

Виджеты
Теперь давайте сделаем несколько виджетов. Начнем с редактора, то есть просто Text. Мы даем ему корневой элемент в качестве мастера. Мы устанавливаем высоту и ширину, которые здесь не имеют значения. Мы устанавливаем цвет фона и переднего плана (текста) с помощью наших переменных. Затем мы поместили здоровенную границу и рельеф до плоского, что привело к красивой прокладке для нашей текстовой области. Мы также задаем цвет каретки с помощью параметра insertbackground. Затем размещаем виджет с пакетом:

# Making the Editor Area
editor = Text(
    root,
    height=5,
    width=width,
    bg=editorBackground,
    fg=editorTextColor,
    border=30,
    relief=FLAT,
    insertbackground=caretColor
)
editor.pack(expand=1, fill=BOTH, side=LEFT)
Мы привязываем событие KeyRelease к нашей функции changes(), которую мы определим, выделяя область отображения и обновляя текст. Затем мы устанавливаем фокус на редакторе с focus_set(). Мы также вставляем некоторый начальный текст в редактор:

# Bind <KeyReleas> so every change is registered
editor.bind('<KeyRelease>', changes)
editor.focus_set()

# Insert a starting text
editor.insert(INSERT, """#Heading 1

##Heading 2

###Heading 3

This is a *bold* move!


- Markdown Editor -

""")
Мы также создаем текстовую область для дисплея. Это очень похоже на область редактора. Но мы установили его отключенным, чтобы пользователь не мог его редактировать:

# Making the Display Area
display = Text(
    root,
    height=5,
    width=width,
    bg=displayBackground,
    fg=displayTextColor,
    border=30,
    relief=FLAT,
    font=f"{displayFontName} {normalSize}",
)
display.pack(expand=1, fill=BOTH, side=LEFT)

# Disable the Display Area so the user cant write in it
# We will have to toggle it so we can insert text
display['state'] = DISABLED
Вспомогательные функции
Теперь определим три функции. Имейте в виду, что мы должны вставить эти определения в начале кода, потому что мы использовали их в коде раньше.

changes()

Эта функция была привязана к событию KeyRelease области редактирования, и она будет обрабатывать изменения, синхронизировать две текстовые области и выделять определенные их части.

В функции у нас есть параметр с именем event, который не нужен, но должен определить его, потому что событие передаст себя функции. Затем мы устанавливаем нормальное состояние дисплея, чтобы его можно было редактировать. После этого мы удаляем его содержимое с помощью метода delete(). Здесь 1.0 означает первую букву в первой строке, а END означает конец содержимого.

def changes(event=None):
    display['state'] = NORMAL

    # Clear the Display Area
    display.delete(1.0, END)
Продолжая, мы получаем текст редактора и сохраняем его в переменной. Затем мы также копируем это значение в другую переменную, потому что в следующих двух строках мы удаляем # и * из текста, чтобы он выглядел лучше. Но мы сохраняем необработанную версию, чтобы мы могли искать шаблоны. Затем мы вставляем текст на дисплей:

    # Insert the content of the Edit Area into the Display Area
    text = editor.get('1.0', END)

    # Save Raw Text for later
    textRaw = text

    # Remove Unwanted Characters
    text = ''.join(text.split('#'))
    text = ''.join(text.split('*'))

    display.insert(1.0, text)
Затем мы просматриваем наш список замен и сохраняем каждый элемент в другой переменной, распаковывая их:

    # Loop through each replacement, unpacking it fully
    for pattern, name, fontData, colorData, offset in replacements:
        # Get the location indices of the given pattern
        locations = search_re(pattern, textRaw, offset)
Затем мы называем наш search_re (текст), который вернет список, подобный этому. Где каждый кортеж представляет начальную и конечную позицию соответствующего шаблона:

[("1.3", "1.7"), ("2.3", "2.5")]
Затем мы также просматриваем этот список и добавляем тег в эти позиции с именем. Эти теги позволяют нам стилизовать определенные части текста.

        # Add tags where the search_re function found the pattern
        for start, end in locations:
            display.tag_add(name, start, end)
Затем, в конце цикла, мы также настраиваем этот тег для использования наших данных шрифта и цвета. Мы получаем доступ к тегу по его имени.

Последнее, что мы делаем в функции, это снова устанавливаем состояние в DISABLED.

        # Configure the tag to use the specified font and color
        # to this every time to delete the previous tags
        display.tag_config(name, font=fontData, foreground=colorData)

    display['state'] = DISABLED
search_re()

Теперь перейдем к функции поиска шаблонов. Мы даем ему шаблон, текст и смещение. В нем мы определяем список совпадений, который будет возвращен в конце:

def search_re(pattern, text, offset):
    matches = []
Затем мы разделяем текст на \n, используя метод splitlines() на нем, и перечисляем его. Для каждой строки мы используем функцию finditer() из re, которая вернет список вхождений, чтобы зациклиться на ней:

    text = text.splitlines()
    for i, line in enumerate(text):
        for match in re.finditer(pattern, line):
Затем добавляем кортеж с начальной и конечной позицией и возвращаем список в конце после цикла:

            matches.append(
                (f"{i + 1}.{match.start()}", f"{i + 1}.{match.end() - offset}")
            )
    return matches
rgbToHex()
Теперь также рассмотрим небольшую функцию преобразования RGB в шестнадцатеричный формат. Используя синтаксис "string %s" % (value), мы можем вставить значения из кортежа в строку с заполнителями, немного похожими на f"{var}". Но с помощью этого синтаксиса мы можем преобразовать число в шестнадцатеричное, используя %02x, где x означает шестнадцатеричный, а 02 означает преобразовать его в два символа.

# Convert an RGB tuple to a HEX string using the % Operator
# 02 means print 2 characters
# x means hexadecimal
def rgbToHex(rgb):
    return "#%02x%02x%02x" % rgb
Пусковой
В конце вызываем функцию changes(), поэтому стилизация применяется к начальному тексту, и запускаем основной цикл:

# Starting the Application
changes()
root.mainloop()
Витрина


Заключение
Отлично! Вы успешно создали редактор markdown с помощью кода Python! Посмотрите, как вы можете добавить дополнительные функции в эту программу, такие как:

Сохранение и открытие файлов .md. Эта функциональность описана в учебнике по текстовому редактору.
Выделение кода, встроенного кода и курсивного стиля.