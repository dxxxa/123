# [How to Build a Spreadsheet App with Tkinter in Python](https://www.thepythoncode.com/article/spreadsheet-app-using-tkinter-in-python)
##
# [[] / []]()
В этом учебнике будет показано простое приложение для работы с электронными таблицами с библиотекой пользовательского интерфейса Tkinter. Мы сделаем так, чтобы ячейки могли либо просто содержать значение, либо ссылаться на другие ячейки и выполнять некоторые вычисления. Каждая ячейка будет иметь координату, состоящую из буквы и цифры, представляющей строку и столбец.

И последнее, но не менее важное: мы также делаем так, чтобы если пользователь предоставляет путь к CSV-файлу, он откроет его и вставит значения в правильные позиции. Это будет немного похоже на Microsoft Spreadsheet App Excel, но мы сосредоточимся на функциональности, а не на внешнем виде. Давайте начнем!

Импорт
Во-первых, давайте рассмотрим модули, которые нам нужны для этой программы. Конечно, чтобы сделать пользовательский интерфейс, нам нужен Tkinter, который поставляется с Python. Мы импортируем все оттуда с *, поэтому мы можем легко использовать константы оттуда. Обычно рекомендуется только получить необходимые функции и классы. Мы также импортируем строку, которая имеет константу, называемую ascii_lowercase которая содержит все строчные буквы алфавита. Мы можем использовать это для создания оси X для электронной таблицы.

Затем мы получаем sys, чтобы мы могли получить аргументы, предоставленные пользователем в командной строке. Мы должны использовать argparse для оптимизации нашего приложения командной строки для более крупной программы. И последнее, но не менее важное: мы получаем ctypes для обеспечения осведомленности DPI, поэтому окно имеет более четкую графику. В последней строке вы видите функцию, которая делает это:

# Imports
from tkinter import *
import string
import sys
import ctypes

# Increase Dots Per inch so it looks sharper
ctypes.windll.shcore.SetProcessDpiAwareness(True)
Настройка
Теперь давайте установим кучу важных вещей для нашей программы. Начнем с получения первых семи букв из константы string.ascii_lowercase. Это будет ось X, поэтому вы можете регулировать количество столбцов с количеством букв, взятых оттуда. Нечто подобное мы делаем для оси Y с функцией range().

Обычно это используется в циклах, но эта функция просто возвращает список чисел в заданном диапазоне. Таким образом, мы делаем 12 рядов. Наконец, мы также определяем переменную cells, содержащую словарь. Он будет иметь строковые переменные и метки:

# Define X and Y Axis Lists
xAxis = string.ascii_lowercase[0:7]
yAxis = range(0, 12)

# Cells will hold the strings vars and the labels 
cells = {}
Продолжая, открываем файл, указанный в командной строке. Но сначала мы определим переменную, которая будет содержать это содержимое. Это делается для того, чтобы более поздняя программа не остановилась, поскольку она проверяет значение непосвященной переменной.

Затем мы проверяем, является ли sys.argv длиннее 1, что означает, что пользователь запросил открытие файла. Первым аргументом является само имя файла Python. После этого открываем этот путь к файлу с помощью контекст-менеджера и разделяем содержимое новой строкой. Затем мы зацикливаемся на этом списке и разделяем эти строки на ,:

# Open the content of the given file
# if one was provided and save it as a two 
# dimensional list.
CsvContent = ''
if len(sys.argv) > 1:
    with open(sys.argv[1], 'r') as f:
        CsvContent = f.read().split('\n')
        for i, layer in enumerate(CsvContent):
            CsvContent[i] = layer.split(',')
Затем мы создаем новое окно верхнего уровня, которое будет выступать в качестве корня нашего приложения с графическим интерфейсом, и устанавливаем заголовок. Если программа открывается с файлом, мы добавляем это имя к заголовку; если нет, он просто говорит Приложение для электронных таблиц. Мы делаем это с троичным оператором:

# Make a new Top Level Element (Window)
root = Tk()
# Set the the title to also mention the given file name
# if there is one
title = "Spreadsheet App" if CsvContent == '' else f"Spreadsheet App - {sys.argv[1]}"
root.title(title)
Создание элементов
Теперь сгенерируем некоторые элементы. Начнем с меток для осей Y и X. Для yAxis мы просто зацикливаемся на нем и создаем новый элемент Label, где текст является значением итерации. Затем мы указываем позицию с помощью функции grid(), где мы добавляем к строке, потому что верхняя строка - это метки x:

# Display the Y-axis labels
for y in yAxis:
    label = Label(root, text = y, width=5, background='white')
    label.grid(row=y + 1, column=0)
Для оси X мы должны использовать функцию enumerate(), поскольку буква не является допустимым значением для параметра столбца функции сетки. Устанавливаем ширину 35 пикселей:

# Display the X-axis labels with enumerate
for i, x in enumerate(xAxis):
    label = Label(root, text = x, width=35, background='white')
    label.grid(row=0, column=i + 1, sticky='n')
Затем мы также делаем сами клетки. Для этого делаем вложенный цикл с осью y и x. Еще раз нужно перечислить. Сразу после этого мы создаем уникальный идентификатор, который идентифицирует ячейку с двумя осями:

# Display the Cells, by using a nested loop
for y in yAxis:
    for xcoor, x in enumerate(xAxis):
        # Generate a Unique ID for the cell with the coordinates
        id = f'{x}{y}'
После этого мы создаем объект StringVar(), который имеет уникальный идентификатор в качестве имени. Этот объект позволяет нам проследить значение этой ячейки позже:

        # Make String Var associated with the Cell
        var = StringVar(root, '', id)
Затем мы делаем два элемента; один Entry, где пользователь может ввести желаемое значение, и один мет, который покажет вычисляемое значение записи. Мы еще раз размещаем эти элементы с функцией grid(). Мы добавляем 1 к обеим осям из-за меток, которые мы сделали ранее. Запись имеет ширину 30, а метка имеет ширину 5, которая совпадает с буквенными метками.

        # Make Entry and label, offset each axis by one because of the lables
        e = Entry(root, textvariable=var, width=30)
        e.grid(row=y + 1, column=xcoor + 1)

        label = Label(root, text = '', width=5)
        label.grid(row=y + 1, column=xcoor + 1, sticky='e')
После этого сохраняем строку var и ссылку на метку и добавляем указанный id в словарь ячеек. Если бы мы вообще не сохранили строковую переменную, она была бы уничтожена:

        # Save the string var and a reference to the labels in the dictionary
        cells[id] = [var, label]
И последнее, но не менее важное: мы проверяем, был ли открыт CSV-файл, и если это так, мы пытаемся получить содержимое в текущем положении в сетке и задаем значение string var:

        # Insert CSV content if it possible
        if CsvContent != '':
            try:
                var.set(CsvContent[y][xcoor])
            except:
                pass
В самом конце программы мы вызываем нашу функцию updateAllCells(), которая будет обновлять все ячейки каждые десять миллисекунд, и вызываем функцию основного цикла, поэтому отображается окно:

# Start the updating Process
updateAllCells()
# Run the Mainloop
root.mainloop()
Функции
Теперь определим две важные функции, которые позволяют использовать систему отсчета. Помните, что эти функции должны быть определены перед кодом ранее в программе.

Функция оценки

Для каждой ячейки будет вызываться функция evaluateCell(); он либо оценит содержимое ячейки, либо просто вставит ее значение в метку. Он должен быть рекурсивным, поэтому возможны многослойные ссылки. Он будет принимать cellId. в функции; сначала мы получаем строку var из словаря ячеек, а затем значение оттуда. Мы также делаем контент ниже:

# Evaluating a cell
def evaluateCell(cellId):

    # Get the content from the string var
    # and make it lowercase
    content = cells[cellId][0].get()
    content = content.lower()
Затем мы также получаем элемент label из словаря ячеек:

    # get the reference to the label
    label = cells[cellId][1]
Затем мы проверяем, начинается ли содержимое с =. Если это правда, мы знаем, что ценность этих клеток оценивается, и мы начинаем зацикливаться на всех других клетках. Если имя ячейки/идентификатор отображается в содержимом, мы знаем, что это ссылка, поэтому заменяем ссылку вычисляемым значением из этого идентификатора:

    # if the cell starts with a = it is evaluated
    if content.startswith('='):
        # Loop through all cells ...
        for cell in cells:
            # ... and see if their name appears in this cell
            if cell in content.lower():
                # if it is then replace the name occurences 
                # with the evaluated content from there.
                content = content.replace(cell, str(evaluateCell(cell)))
После того, как мы вставили все значения из других ячеек, мы удаляем = из начала, и мы пытаемся оценить содержимое. Если это не сработает, мы установим для содержимого ЗНАЧЕНИЕ NAN. И последнее, но не менее важное: мы устанавливаем текстовое содержимое метки в качестве оцениваемого содержимого и возвращаем его:

        # Get the content without the = and try to evaluate it
        content = content[1:]
        try:
            content = eval(content)
        except:
            content = 'NAN'
        label['text'] = content
        return content
Мы пропускаем все это, если содержимое не начинается с = и просто устанавливаем текстовое содержимое и возвращаем его:

    # If not, the label just shows the content
    else:
        label['text'] = content
        return content
Оценка всех функций

Теперь эта функция будет вызывать себя один раз в десять миллисекунд. Мы делаем это, вызывая метод after(ms, func) в корневом каталоге. И мы зацикливаемся на всех ячейках и вызываем функцию evaluateCell() для каждой из них:

# Call the eval function for every cell every ten milliseconds.
def updateAllCells():

    # Call it again
    root.after(10, updateAllCells)

    # Loop through all cells
    for cell in cells:
        evaluateCell(cell)
Витрина
Теперь давайте посмотрим на нашу программу в действии. Во-первых, мы просто открываем программу и пишем несколько ячеек. А затем, открываем программу с CSV-файлом, так оттуда вставляется содержимое:

Витрина

Заключение
Отлично! Вы успешно создали простое приложение для работы с электронными таблицами с помощью кода Python! Посмотрите, как вы можете добавить дополнительные функции в эту программу, например, сохранить CSV-файл после загрузки.