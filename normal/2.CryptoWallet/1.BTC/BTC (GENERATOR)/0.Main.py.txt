#https://github.com/burakcanekici/BitcoinAddressGenerator
#Образец для создания адреса биткойн
#Это пример кода для генерации биткойн-адресов. Транзакции обеспечивают передачу активов между биткойн-кошельками, 
#которые хранят закрытый ключ и биткойн-адрес. Закрытый ключ гарантирует, что транзакция исходит от владельца кошелька. 
#Возможно создание биткойн-адреса в автономном режиме. Этот код объясняет, как вы можете шаг за шагом сгенерировать биткойн-адрес. 
#Как вы видите на рисунке ниже, во время генерации адреса биткойна выполняются некоторые операции.
#Давайте начнем изучать, как мы можем сгенерировать биткойн-адрес;


import hashlib,base58,binascii,ecdsa, codecs

# Step1: Generate ECDSA Private Key")
# Шаг № 1: Алгоритм цифровой подписи с эллиптической кривой используется для генерации закрытого ключа, поскольку криптография с открытым ключом обеспечивает принцип подписи биткойнов.
ecdsaPrivateKey = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1)
print("ECDSA Private Key: ", ecdsaPrivateKey.to_string().hex())
print("------------------------------------------------------")

# Step2: Generate ECDSA Public Key from value at Step#1
# Шаг № 2: Из-за криптографии с открытым ключом нам нужен открытый ключ, который зависит от закрытого ключа. Поэтому мы также генерируем его с помощью алгоритма цифровой подписи с эллиптической кривой.
ecdsaPublicKey = '04' +  ecdsaPrivateKey.get_verifying_key().to_string().hex()
print("ECDSA Public Key: ", ecdsaPublicKey)
print("------------------------------------------------------")

# Step3: SHA256(value at Step#2)
# Шаг №3: Мы применяем SHA256 к открытому ключу ECDSA, который создается на этапе №2.
hash256FromECDSAPublicKey = hashlib.sha256(binascii.unhexlify(ecdsaPublicKey)).hexdigest()
print("SHA256(ECDSA Public Key): ", hash256FromECDSAPublicKey)
print("------------------------------------------------------")

# Step4: RIDEMP160(value at Step#3)
# Шаг № 4: Мы применяем RIDEMP160 к значению, которое создается на Шаге № 3, и получаем значение как 20 байтов.
ridemp160FromHash256 = hashlib.new('ripemd160', binascii.unhexlify(hash256FromECDSAPublicKey))
print("RIDEMP160(SHA256(ECDSA Public Key)): ", ridemp160FromHash256.hexdigest())
print("------------------------------------------------------")

# Step5: Prepend 00 as network byte to value at Step#4
# Шаг №5: Мы добавляем 00 в качестве сетевого байта к значению, которое создается на этапе №4.
prependNetworkByte = '00' + ridemp160FromHash256.hexdigest()
print("Prepend Network Byte to RIDEMP160(SHA256(ECDSA Public Key)): ", prependNetworkByte)
print("------------------------------------------------------")

# Step6: Apply SHA256 to value at Step#5 at 2 times to generate Checksum
# Шаг № 6: Мы применяем двойной SHA256 к значению, которое создается на Шаге № 5 для контрольной суммы.
hash = prependNetworkByte
for x in range(1,3):
    hash = hashlib.sha256(binascii.unhexlify(hash)).hexdigest()
    print("\t|___>SHA256 #", x, " : ", hash)
print("------------------------------------------------------")

# Step7: Get first 4 bytes of value at Step#6 as Checksum
# Шаг № 7: Мы получаем 4 байта значения, которое создается на Шаге № 6 как контрольная сумма.
cheksum = hash[:8]
print("Checksum(first 4 bytes): ", cheksum)
print("------------------------------------------------------")

# Step8: Append Checksum to value at Step#5
# Шаг №8: Мы добавляем значение контрольной суммы, созданное на этапе №7, к значению, которое создается на этапе №5.
appendChecksum = prependNetworkByte + cheksum
print("Append Checksum to RIDEMP160(SHA256(ECDSA Public Key)): ", appendChecksum)
print("------------------------------------------------------")

# Step9: Generate Bitcoin Address with apply Base58 Encoding to value at Step#8
# Шаг № 9: Мы применили кодировку Base58 к значению, которое создается на этапе № 8. После кодирования Base58 мы получаем значение, которое является биткойн-адресом (в Python результат b58encode должен декодироваться в utf-8 для отображения)
bitcoinAddress = base58.b58encode(binascii.unhexlify(appendChecksum))
print("Bitcoin Address: ", bitcoinAddress.decode('utf8'))