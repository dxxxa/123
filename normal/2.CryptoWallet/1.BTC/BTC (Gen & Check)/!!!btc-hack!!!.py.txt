#https://github.com/DavidMGilbert/btc-hack
#https://github.com/ay-bros-inc/btc-hack
#Автоматический коллайдер биткойн-кошелька, который подбирает случайные адреса кошельков, проверяя их баланс в режиме реального времени.

#Зависимости
#Python 3.6 или выше
#btc-hack.py попытается автоматически установить необходимые модули, если они отсутствуют. 
#Если это не удастся, вы можете найти необходимые модули, перечисленные в файле requirements.txt.
#base58
#ecdsa
#requests

#Доказательство концепции
#Закрытый ключ - это секретное число, которое позволяет тратить биткойны.
#Если в кошельке есть биткойны, то закрытый ключ позволит человеку контролировать кошелек и тратить весь баланс кошелька. 
#Таким образом, эта программа пытается найти закрытые ключи биткойнов, которые соответствуют кошелькам с положительным балансом. 
#Однако, поскольку невозможно узнать, какие закрытые ключи управляют кошельками с деньгами, а какие закрытые ключи контролируют пустые кошельки, 
#мы должны случайным образом просмотреть все возможные закрытые ключи, которые существуют, и надеяться найти тот, у которого есть баланс.

#Эта программа, по сути, представляет собой алгоритм прямого перебора. 
#Он непрерывно генерирует случайные закрытые ключи биткойнов, конвертирует закрытые ключи в соответствующие адреса кошельков, а затем проверяет баланс адресов. 
#Если кошелек с балансом обнаружен, то закрытый ключ, открытый ключ и адрес кошелька сохраняются в текстовом файле found.txtна жестком диске пользователя. 
#Конечная цель состоит в том, чтобы случайно найти бумажник с балансом из 2 160 возможных кошельков в существовании.

#Как это работает
#Закрытые ключи генерируются случайным образом для создания 32-байтовой шестнадцатеричной строки с использованием криптографически безопасной os.urandom()функции.
#Закрытые ключи преобразуются в соответствующие им открытые ключи с помощью starkbank-ecdsa модуля Python. 
#Затем открытые ключи преобразуются в их кошельке адрес Bitcoin используя binasciiи hashlib стандартные библиотеки.

#Сгенерированный адрес ищется с помощью онлайн-API, и если обнаруживается, что адрес имеет баланс, то закрытый ключ, открытый ключ и адрес кошелька сохраняются в текстовом файле found.txt на жестком диске пользователя.
#Эта программа также использует многопроцессорную обработку через multiprocessing.Process() функцию для выполнения параллельных вычислений. 
#К сожалению, в настоящее время это ограничено из-за ограничений API 300 запросов в минуту.

#Эффективность
#Эта программа занимает 0.0032457721секунды, чтобы перебрать один биткойн-адрес.
#Однако через multiprocessing.Process() параллельный процесс создается для каждого процессора вашего компьютера. 
#Таким образом, эта программа может перебирать адреса за 0.0032457721 ÷ cpu_count()секунды.

#API FAQ
#В настоящее время программа запускает и запрашивает api sochain.com. 
#Поскольку этот api позволяет бесплатно выполнять до 300 запросов в минуту, это показалось действительно хорошим выбором, 
#позволяющим тестировать примерно 18 000 адресов в час, 432 000 адресов в сутки или 3 000 000 адресов в неделю!

#Каждый раз, когда эта программа проверяет баланс сгенерированного адреса, она выводит результат пользователю. 
#Если будет обнаружен пустой кошелек, адрес кошелька будет напечатан на терминале. 
#Пример:
#1Kz2CTvjzkZ3p2BQb5x5DX6GEoHX2jFS45: 0,0

#Однако, если кошелек с балансом будет найден, то вся необходимая информация о кошельке будет сохранена в текстовом файле found.txt. 
#Пример:
#адрес: 1Kz2CTvjzkZ3p2BQb5x5DX6GEoHX2jFS45
#закрытый ключ: 5A4F3F1CAB44848B2C2C515AE74E9CC487A9982C9DD695810230EA48B1DCEADD
#WIF закрытый ключ: 5JW4RCAXDbocFLK9bxqw5cbQwuSn86fpbmz2HhT9nvKMTh68hjm
#открытый ключ: 04393B30BC950F358326062FF28D194A5B28751C1FF2562C02CA4DFB2A864DE63280CC140D0D540EA1A5711D1E519C842684F42445C41CB501B7EA00361699C320
#баланс: 0,0001456

#Потребление памяти
#Эта программа использует примерно 2 ГБ ОЗУ на процессор. 
#Поскольку эта программа может использовать многопроцессорную обработку, некоторые данные распределяются между потоками, что затрудняет точное измерение использования ОЗУ.

#Трассировка стека потребления памяти была сделана с помощью mprof для отслеживания этой программы грубой силой 10 000 адресов на машине с 4 логическими процессорами и 8 ГБ ОЗУ. 
#В результате было создано 4 дочерних процесса, каждый из которых потреблял 2100 МБ ОЗУ (~ 2 ГБ).



# Purpyl Media Bitcoin Brute Forcer
# Made by David Gilbert
# https://github.com/purpyl-media/btc-hack
# https://www.purpyl.media

try:
    import sys
    import os
    import time
    import hashlib
    import binascii
    import multiprocessing
    from multiprocessing import Process, Queue
    from multiprocessing.pool import ThreadPool
    import threading
    import base58
    import ecdsa
    import requests

# If required imports are unavailable, we will attempt to install them!

except ImportError: 
    import subprocess
    subprocess.check_call(["python3", '-m', 'pip', 'install', 'base58==1.0.0'])
    subprocess.check_call(["python3", '-m', 'pip', 'install', 'ecdsa==0.13'])
    subprocess.check_call(["python3", '-m', 'pip', 'install', 'requests==2.19.1'])
    import base58
    import ecdsa
    import requests

def generate_private_key():
    return binascii.hexlify(os.urandom(32)).decode('utf-8')

def private_key_to_WIF(private_key):
    var80 = "80" + str(private_key) 
    var = hashlib.sha256(binascii.unhexlify(hashlib.sha256(binascii.unhexlify(var80)).hexdigest())).hexdigest()
    return str(base58.b58encode(binascii.unhexlify(str(var80) + str(var[0:8]))), 'utf-8')

def private_key_to_public_key(private_key):
    sign = ecdsa.SigningKey.from_string(binascii.unhexlify(private_key), curve = ecdsa.SECP256k1)
    return ('04' + binascii.hexlify(sign.verifying_key.to_string()).decode('utf-8'))

def public_key_to_address(public_key):
    alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    count = 0; val = 0
    var = hashlib.new('ripemd160')
    var.update(hashlib.sha256(binascii.unhexlify(public_key.encode())).digest())
    doublehash = hashlib.sha256(hashlib.sha256(binascii.unhexlify(('00' + var.hexdigest()).encode())).digest()).hexdigest()
    address = '00' + var.hexdigest() + doublehash[0:8]
    for char in address:
        if (char != '0'):
            break
        count += 1
    count = count // 2
    n = int(address, 16)
    output = []
    while (n > 0):
        n, remainder = divmod (n, 58)
        output.append(alphabet[remainder])
    while (val < count):
        output.append(alphabet[0])
        val += 1
    return ''.join(output[::-1])

def get_balance(address):
    time.sleep(0.2) #This is to avoid over-using the API and keep the program running indefinately.
    try:
        response = requests.get("https://sochain.com/api/v2/address/BTC/" + str(address))
        return float(response.json()['data']['balance']) 
    except:
        return -1

def data_export(queue):
    while True:
        private_key = generate_private_key()
        public_key = private_key_to_public_key(private_key)
        address = public_key_to_address(public_key)
        data = (private_key, address)
        queue.put(data, block = False)

def worker(queue):
    while True:
        if not queue.empty():
            data = queue.get(block = True)
            balance = get_balance(data[1])
            process(data, balance)

def process(data, balance):
    private_key = data[0]
    address = data[1]
    if (balance == 0.00000000):
        print("{:<34}".format(str(address)) + " : " + str(balance))
    if (balance > 0.00000000):
        file = open("found.txt","a")
        file.write("address: " + str(address) + "\n" +
                   "private key: " + str(private_key) + "\n" +
                   "WIF private key: " + str(private_key_to_WIF(private_key)) + "\n" +
                   "public key: " + str(private_key_to_public_key(private_key)).upper() + "\n" +
                   "balance: " + str(balance) + "\n\n")
        file.close()

def thread(iterator):
    processes = []
    data = Queue()
    data_factory = Process(target = data_export, args = (data,))
    data_factory.daemon = True
    processes.append(data_factory)
    data_factory.start()
    work = Process(target = worker, args = (data,))
    work.daemon = True
    processes.append(work)
    work.start()
    data_factory.join()

if __name__ == '__main__':
    try:
        pool = ThreadPool(processes = multiprocessing.cpu_count()*1)#*2 больше ядер включит
        pool.map(thread, range(0, 1)) # Limit to single CPU thread as we can only query 300 addresses per minute
    except:
        pool.close()
        exit()