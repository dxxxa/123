# [How to Use Regular Expressions in Python](https://www.thepythoncode.com/article/work-with-regular-expressions-in-python)
##
# [[] / []]()
Регулярное выражение — это специальная последовательность символов, которая формирует шаблон поиска, его можно использовать для проверки того, содержит ли строка заданный шаблон, а также для извлечения всех вхождений этого шаблона и многого другого.

Regex повсюду, от проверки адресов электронной почты, паролей, форматов дат до использования в поисковых системах, поэтому это важный навык для любого разработчика, и большинство языков программирования предоставляют возможности regex.

Если вы знакомы с Linux, я думаю, вы уже видели некоторые регулярные выражения, использующие команды sed и grep, но в этом уроке мы будем переуправляемым модулем на Python. Вот методы, которые мы собираемся рассмотреть:

Совпадающие строки
Искать Метод
Поиск нескольких совпадений
Замена матчей
Мы не будем рассматривать основы построения регулярных выражений с нуля в этом учебнике, вместо этого мы сосредоточимся больше на том, как вы можете эффективно использовать regex на Python.

Совпадающие строки
Для демонстрации использования функции re.match() предположим, что вы хотите проверить пароли пользователей. Например, вы хотите убедиться, что пароль, который они вводят, имеет длину не менее 8 символов и содержит хотя бы одну цифру. Следующий код делает это:

import re # stands for regular expression 
# a regular expression for validating a password
match_regex = r"^(?=.*[0-9]).{8,}$"
# a list of example passwords
passwords = ["pwd", "password", "password1"]
for pwd in passwords:
    m = re.match(match_regex, pwd)
    print(f"Password: {pwd}, validate password strength: {bool(m)}")
match_regex является регулярным выражением, ответственным за проверку критериев пароля, о которых мы упоминали ранее:

^: Начальный символ.
(?=.*[0-9]): убедитесь, что строка содержит хотя бы цифру.
. {8,}: Убедитесь, что строка содержит не менее 8 символов.
$: Конечный символ.
Затем мы использовали список паролей для сопоставления, вот вывод:

Password: pwd, validate password strength: False
Password: password, validate password strength: False
Password: password1, validate password strength: True
Как и ожидалось, провалился для первых двух, и преуспел для последнего. Первый пароль (pwd) содержит менее 8 символов, второй не содержит цифры, тогда как третий имеет не менее 8 символов и содержит цифру.

Обратите внимание, что мы обернули метод re.match() встроенным методом bool(), чтобы вернуть логическое значение, указывающее, соответствует ли строка шаблону.

Искать Метод
Хорошим примером демонстрации метода re.search() является поиск определенного шаблона в строке. В этом разделе мы попробуем извлечь IPv4-адрес из части выходных данных команды ipconfig в Windows:

import re

# part of ipconfig output
example_text = """
Wireless LAN adapter Wi-Fi:
   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::380e:9710:5172:caee%2
   IPv4 Address. . . . . . . . . . . : 192.168.1.100
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1
"""
# regex for IPv4 address
ip_address_regex = r"((25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])(\.(?!$)|$)){4}"
# use re.search() method to get the match object
match = re.search(ip_address_regex, example_text)
print(match)
Не беспокойтесь о ip_address_regex выражении, оно в основном проверяет IPv4-адрес (убедившись, что каждое число из общего числа 4 не превышает 255).

Мы использовали re.search() в этом случае для поиска действительного IPv4-адреса, вот вывод:

<_sre.SRE_Match object; span=(281, 292), match='192.168.1.1'>
re.search() возвращает объект соответствия, который имеет начальный и конечный индексы найденной строки и фактическую строку, в данном случае он возвращает '192.168.1.1' в качестве сопоставленной строки. Вы можете использовать:

match.start(), чтобы получить индекс первого символа найденного шаблона.
match.end(), чтобы получить индекс последнего символа найденного шаблона.
match.span(), чтобы получить начало и конец в виде кортежа (начало, конец).
match.group(), чтобы получить фактическую найденную строку.
Как видите, он возвращает только первое совпадение и игнорирует оставшиеся допустимые IP-адреса. В следующем разделе мы увидим, как извлечь несколько совпадений в строку.

Поиск нескольких совпадений
Мы будем использовать выходные данные той же команды (ipconfig), но на этот раз мы попытаемся использовать регулярные выражения для сопоставления MAC-адресов:

import re

# fake ipconfig output
example_text = """
Ethernet adapter Ethernet:
   Media State . . . . . . . . . . . : Media disconnected
   Physical Address. . . . . . . . . : 88-90-E6-28-35-FA
Ethernet adapter Ethernet 2:
   Physical Address. . . . . . . . . : 04-00-4C-4F-4F-60
   Autoconfiguration IPv4 Address. . : 169.254.204.56(Preferred)
Wireless LAN adapter Local Area Connection* 2:
   Media State . . . . . . . . . . . : Media disconnected
   Physical Address. . . . . . . . . : B8-21-5E-D3-66-98
Wireless LAN adapter Wi-Fi:
   Physical Address. . . . . . . . . : A0-00-79-AA-62-74
   IPv4 Address. . . . . . . . . . . : 192.168.1.101(Preferred)
   Default Gateway . . . . . . . . . : 192.168.1.1
"""
# regex for MAC address
mac_address_regex = r"([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})"
# iterate over matches and extract MAC addresses
extracted_mac_addresses = [ m.group(0) for m in re.finditer(mac_address_regex, example_text) ]
print(extracted_mac_addresses)
После определения регулярного выражения мы использовали функцию re.finditer(), чтобы найти все вхождения MAC-адресов в переданной строке.

Поскольку finditer() возвращает итератор объектов соответствия, мы использовали понимание списка для извлечения только найденных MAC-адресов с помощью group(0) (всего совпадения). Проверьте выходные данные:

['88-90-E6-28-35-FA', '04-00-4C-4F-4F-60', 'B8-21-5E-D3-66-98', 'A0-00-79-AA-62-74']
Удивительно, мы успешно извлекли все MAC-адреса в этой строке. В следующем разделе мы увидим, как использовать regex для замены вхождений шаблона в строках.

Замена матчей
Если у вас есть опыт работы с веб-парсингом, вы можете столкнуться с веб-сайтом, который использует такую службу, как CloudFlare, чтобы скрыть адреса электронной почты из инструментов сбора электронной почты. В этом разделе мы сделаем именно это, учитывая строку, содержащую адреса электронной почты, мы заменим каждый из адресов маркером «[email protected]»:

import re

# a basic regular expression for email matching
email_regex = r"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+"
# example text to test with
example_text = """
Subject: This is a text email!
From: John Doe <john@doe.com>
Some text here!
===============================
Subject: This is another email!
From: Abdou Rockikz <example@domain.com>
Some other text!
"""
# substitute any email found with [email protected]
print(re.sub(email_regex, "[email protected]", example_text))
Мы использовали метод re.sub(), который принимает 3 аргумента, первый - регулярное выражение (шаблон), второй - замена всех найденных шаблонов, третий - целевая строка, вот вывод:

Subject: This is a text email!
From: John Doe <[email protected]>
Some text here!
===============================
Subject: This is another email!
From: Abdou Rockikz <[email protected]>
Some other text!
Отлично, как мы и ожидали, функция re.sub() возвращает строку, полученную путем замены крайних левых неперекрывающихся появлений шаблона в строке на указанную замену (2-й аргумент).

Заключение
Теперь у вас есть навыки использования регулярных выражений в Python, обратите внимание, что мы не охватили все методы, предоставляемые модулем re, есть и другие удобные функции, такие как split() и fullmatch(),поэтому я настоятельно рекомендую вам проверить официальную документацию Python.

Если вы не знаете, как создавать и конструировать регулярные выражения для своих нужд, вы можете проверить официальную документацию или этот учебник.

Хотите узнать больше?
Наконец, если вы новичок и хотите изучать Python, я предлагаю вам пройти курс Python For Everybody Coursera, в котором вы узнаете много нового о Python, удачи!